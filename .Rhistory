# Media recortada (recortar según criterio del estudiante)
mean(pnud$indpercep, na.rm = T, trim = 0.025)
# Mediana
median(pnud$indpercep, na.rm = T)
### Medidas de posición ###
# Cuartiles
quantile(pnud$indpercep, na.rm = T)
# Desviación estándar
sd(pnud$indpercep, na.rm = T)
# Coeficiente de variación centrado en la media
sd(pnud$indpercep, na.rm = TRUE)/mean(pnud$indpercep, na.rm = TRUE) * 100
# Moda
moda <- function(x, na.rm = FALSE) {
if(na.rm){
x = x[!is.na(x)]
}
ux <- unique(x)
return(ux[which.max(tabulate(match(x, ux)))])
}
moda(pnud$indpercep, na.rm = T)
# Percentil
quantile(pnud$indpercep, probs = seq(0, 1, .01), na.rm = T)
ggplot(pnud, aes(x = factor(indpercep_recod))) +
geom_bar(width = 0.4, fill=rgb(0,0.4,0.2,0.8)) +
scale_x_discrete("Índice de Percepción de Desigualdad",
na.translate = FALSE) +
scale_y_continuous("Puntaje") +
labs(title = "Percepción de desigualdad en Chile (2016)")
### Medidas de tendencia central ###
# Media
mean(pnud_female$indpercep, na.rm = T)
### Medidas de tendencia central ###
# Media
mean(pnud_male$indpercep, na.rm = T)
max(pnud_female$indpercep, na.rm = T)
summary(pnud_male$indpercep)
summary(pnud_female$indpercep)
sd(pnud_male$indpercep, na.rm=T)
sd(pnud_female$indpercep, na.rm=T)
# Coeficiente de variación centrado en la media
sd(pnud_female$indpercep, na.rm = TRUE)/mean(pnud_female$indpercep, na.rm = TRUE) * 100
# Coeficiente de variación centrado en la media
sd(pnud_female$indpercep, na.rm = TRUE)/mean(pnud_female$indpercep, na.rm = TRUE) * 100
# Coeficiente de variación centrado en la media
sd(pnud_male$indpercep, na.rm = TRUE)/mean(pnud_male$indpercep, na.rm = TRUE) * 100
### Medidas de tendencia central ###
# Media
mean(pnud_female$indpercep, na.rm = T)
### Medidas de tendencia central ###
# Media
mean(pnud_male$indpercep, na.rm = T)
# Coeficiente de variación centrado en la media
sd(pnud_female$indpercep, na.rm = TRUE)/mean(pnud_female$indpercep, na.rm = TRUE) * 100
# Coeficiente de variación centrado en la media
sd(pnud_male$indpercep, na.rm = TRUE)/mean(pnud_male$indpercep, na.rm = TRUE) * 100
sd(pnud_female$indpercep)
sd(pnud_female$indpercep, na.rm = T)
mean(pnud_female$indpercep, na.rm = TRUE)
sd(pnud_male$indpercep, na.rm = T)
mean(pnud_male$indpercep, na.rm = T)
ggplot(pnud, aes(x = factor(indpercep_recod))) +
geom_bar(width = 0.4, fill=rgb(0,0.4,0.2,0.8)) +
scale_x_discrete("Índice de Percepción de Desigualdad",
na.translate = FALSE) +
scale_y_continuous("Frecuencia") +
labs(title = "Percepción de desigualdad en Chile (2016)")
ggsave("Gráfico desigualdad.png", width = 20, height = 15, units = "cm", dpi = "retina")
install.packages(c("bibliometrix", "boot", "bslib", "cachem", "class", "colorspace", "corrplot", "curl", "dendextend", "devtools", "dplyr", "ellipsis", "ggeffects", "gh", "httpuv", "insight", "installr", "KernSmooth", "lme4", "magick", "MASS", "misty", "multcomp", "nnet", "openssl", "performance", "pillar", "processx", "R.cache", "RcppParallel", "rJava", "rlang", "rmarkdown", "rpf", "sass", "sjlabelled", "sjmisc", "spatial", "statmod", "stringi", "systemfonts", "tibble", "tidyselect", "vctrs", "viridis", "xfun"))
install.packages(c("dplyr", "ergm", "GGally", "rio", "stringi"))
install.packages(c("car", "cli", "corrplot", "cpp11", "ggplot2", "lavaan", "mime", "OpenMx", "tergm", "testthat", "vroom"))
gc()
library(stringr)
a = "Chile"
b = "United States"
str_equal(a, b)
reprex()
library(reprex)
reprex()
install.packages("stringr")
install.packages("stringr")
library(stringr)
a = "Chile"
b = "United States"
str_equal(a, b)
reprex()
library(reprex)
install.packages("stringr")
install.packages("stringr")
library(stringr)
a = "Chile"
b = "United States"
str_equal(a, b)
reprex()
library(reprex)
reprex()
library(stringr)
a = "Chile"
b = "United States"
str_equal(a, b)
reprex()
library(reprex)
install.packages("stringr")
install.packages("stringr")
library(stringr)
a = "Chile"
b = "United States"
str_equal(a, b)
reprex()
pacman::p_load(dplyr, ggplot2, sjPlot, cowplot, stringr, bibliometrix, viridis,
beepr, zoo, ggrepel, hrbrthemes, xlsx, readxl, scales)
data("countries")
View(countries)
1. I used ARTofR everyday
2. I used ARTofR everyday and it makes my R script so neat. I used ARTofR everyday and it makes my R script so neat.
3. I recommended this pacakge to all my families. I recommended this pacakge to all my families.
4. Yes, even my grandmother like it!
install.packages("ARTofR")
xxx_box()
library(ARTofR)
xxx_box()
xxx_title1('Analysis Fondecyt')
# Falta data para School SES y teacher attributes (SIMCE, Categorías de Desempeño)
library(googledrive)
temp <- tempfile(fileext = ".zip")
# Falta data para School SES y teacher attributes (SIMCE, Categorías de Desempeño)
library(googledrive)
temp <- tempfile(fileext = ".zip")
dl <- drive_download(
as_id("11LrJEXDMGEcWe1NEuAePUMf97abRYptV"), path = temp, overwrite = TRUE)
beepr::beep()
View(dl)
out <- unzip(temp, exdir = tempdir())
install.packages(c("arm", "backports", "bayestestR", "broom", "bslib", "cli", "conquer", "crayon", "data.table", "datawizard", "dendextend", "desc", "diffobj", "effectsize", "emmeans", "generics", "Hmisc", "hms", "htmlTable", "igraph", "insight", "knitr", "labelled", "lifecycle", "lubridate", "micemd", "mime", "misty", "mitml", "mixmeta", "mvtnorm", "parameters", "performance", "pillar", "pkgload", "plm", "plotly", "qgraph", "questionr", "R.utils", "rbibutils", "rcmdcheck", "RcppArmadillo", "readr", "remotes", "rJava", "rlang", "robustbase", "rootSolve", "rpf", "rvest", "sem", "sessioninfo", "shiny", "stringi", "systemfonts", "testthat", "tibble", "tidyr", "tidytext", "tinytex", "tsna", "tzdb", "usethis", "uuid", "vcd", "viridis", "xfun"))
if (interactive() && requireNamespace("rsthemes", quietly = TRUE)) {
# Set preferred themes if not handled elsewhere..
rsthemes::set_theme_light("One Light {rsthemes}")  # light theme
rsthemes::set_theme_dark("One Dark {rsthemes}") # dark theme
# Whenever the R session restarts inside RStudio...
setHook("rstudio.sessionInit", function(isNewSession) {
# Automatically choose the correct theme based on time of day
rsthemes::use_theme_auto(dark_start = "18:00", dark_end = "6:00")
}, action = "append")
}
beepr::beep()
install.packages("rsthemes")
install.packages("Rtools")
install.packages("rsthemes")
if (interactive() && requireNamespace("rsthemes", quietly = TRUE)) {
# Set preferred themes if not handled elsewhere..
rsthemes::set_theme_light("One Light {rsthemes}")  # light theme
rsthemes::set_theme_dark("One Dark {rsthemes}") # dark theme
# Whenever the R session restarts inside RStudio...
setHook("rstudio.sessionInit", function(isNewSession) {
# Automatically choose the correct theme based on time of day
rsthemes::use_theme_auto(dark_start = "18:00", dark_end = "6:00")
}, action = "append")
}
if (interactive() && requireNamespace("rsthemes", quietly = TRUE)) {
# Set preferred themes if not handled elsewhere..
rsthemes::set_theme_light("One Light {rsthemes}")  # light theme
rsthemes::set_theme_dark("One Dark {rsthemes}") # dark theme
# Whenever the R session restarts inside RStudio...
setHook("rstudio.sessionInit", function(isNewSession) {
# Automatically choose the correct theme based on time of day
rsthemes::use_theme_auto(dark_start = "10:00", dark_end = "10:11")
}, action = "append")
}
library(usethis)
edit_r_profile()
if (as.numeric(format(as.POSIXct(Sys.time(), format = "%H:%M:%S"), "%H")) %in% c(10:11, 21:23)) {
if (rstudioapi::getThemeInfo()$editor != "Solarized Dark") rstudioapi::applyTheme("Solarized Dark")
} else {
if (rstudioapi::getThemeInfo()$editor != "Solarized Light") rstudioapi::applyTheme("Solarized Light")
}
setHook("rstudio.sessionInit", function(chooseTheme) {
if (chooseTheme) {
if (as.numeric(format(as.POSIXct(Sys.time(), format = "%H:%M:%S"), "%H")) %in% c(10:11, 21:23)) {
if (rstudioapi::getThemeInfo()$editor != "Solarized Dark") rstudioapi::applyTheme("Solarized Dark")
} else {
if (rstudioapi::getThemeInfo()$editor != "Solarized Light") rstudioapi::applyTheme("Solarized Light")
}
}
},
action = "replace"
)
library(usethis)
edit_r_profile()
setHook("rstudio.sessionInit", function(chooseTheme) {
if (chooseTheme) {
if (as.numeric(format(as.POSIXct(Sys.time(), format = "%H:%M:%S"), "%H")) %in% c(0:6, 21:23)) {
if (rstudioapi::getThemeInfo()$editor != "Solarized Dark") rstudioapi::applyTheme("Solarized Dark")
} else {
if (rstudioapi::getThemeInfo()$editor != "Solarized Light") rstudioapi::applyTheme("Solarized Light")
}
}
},
action = "replace"
)
setHook("rstudio.sessionInit", function(chooseTheme) {
if (chooseTheme) {
if (as.numeric(format(as.POSIXct(Sys.time(), format = "%H:%M:%S"), "%H")) %in% c(0:6, 21:23)) {
if (rstudioapi::getThemeInfo()$editor != "Solarized Dark") rstudioapi::applyTheme("Solarized Dark")
} else {
if (rstudioapi::getThemeInfo()$editor != "Solarized Light") rstudioapi::applyTheme("Solarized Light")
}
}
},
action = "replace"
)
library(usethis)
edit_r_profile()
if (rstudioapi::getThemeInfo()$editor != "Textmate") rstudioapi::applyTheme("Textmate")
setHook("rstudio.sessionInit", function(chooseTheme) {
if (chooseTheme) {
if (as.numeric(format(as.POSIXct(Sys.time(), format = "%H:%M:%S"), "%H")) %in% c(0:6, 21:23)) {
if (rstudioapi::getThemeInfo()$editor != "Solarized Dark") rstudioapi::applyTheme("Solarized Dark")
} else {
if (rstudioapi::getThemeInfo()$editor != "Textmate") rstudioapi::applyTheme("Textmate")
}
}
},
action = "replace"
)
library(usethis)
edit_r_profile()
setHook("rstudio.sessionInit", function(chooseTheme) {
if (chooseTheme) {
if (as.numeric(format(as.POSIXct(Sys.time(), format = "%H:%M:%S"), "%H")) %in% c(0:6, 21:23)) {
if (rstudioapi::getThemeInfo()$editor != "Solarized Dark") rstudioapi::applyTheme("Solarized Dark")
} else {
if (rstudioapi::getThemeInfo()$editor != "Textmate (default)") rstudioapi::applyTheme("Textmate (default)")
}
}
},
action = "replace"
)
# Read csv or txt from Google Drive ---------------------------------------
library(googledrive)
googledrive::drive_auth()
# Public folder
read_drive <- function(link_drive,sep=",",dec=".") {
require(data.table)
id<-strsplit(link_drive,"id=")[[1]][2]
return(fread(sprintf("https://docs.google.com/uc?id=%s&export=download", id),
sep=sep,dec=dec,integer64 = "character"))
}
read_drive("https://drive.google.com/file/d/18RuUXzfchJiObtph-orGYMaGsA9hZ9Og/view?usp=sharing",
sep = ";")
data = read_drive("https://drive.google.com/file/d/18RuUXzfchJiObtph-orGYMaGsA9hZ9Og/view?usp=sharing",
sep = ";")
data = read_drive("https://drive.google.com/file/d/18RuUXzfchJiObtph-orGYMaGsA9hZ9Og/view?usp=sharing",
sep = ";")
data = read_drive("http://drive.google.com/file/d/18RuUXzfchJiObtph-orGYMaGsA9hZ9Og",
sep = ";")
# Public folder
Leer_Drive<-function(link_drive,sep=",",dec=".") {
require(data.table)
id<-strsplit(link_drive,"id=")[[1]][2]
return(fread(sprintf("https://docs.google.com/uc?id=%s&export=download", id),
sep=sep,dec=dec,integer64 = "character"))
}
datos<-Leer_Drive("https://drive.google.com/open?id=1mhj0hSUuMefcB612NjtT75SWs71P7QBa",sep=";")
head(datos)
datos<-Leer_Drive("https://drive.google.com/file/d/18RuUXzfchJiObtph-orGYMaGsA9hZ9Og/view?usp=sharing",sep=";")
datos<-Leer_Drive("https://drive.google.com/file/d/18RuUXzfchJiObtph-orGYMaGsA9hZ9Og/view?usp=sharing",sep=";")
library(curl)
datos<-Leer_Drive("https://drive.google.com/file/d/18RuUXzfchJiObtph-orGYMaGsA9hZ9Og/view?usp=sharing",sep=";")
head(datos)
datos<-Leer_Drive("https://drive.google.com/file/d/18RuUXzfchJiObtph-orGYMaGsA9hZ9Og/view?usp=sharing",sep=";")
# Public folder
Leer_Drive<-function(link_drive,sep=",",dec=".") {
require(data.table)
id<-strsplit(link_drive,"id=")[[1]][2]
return(fread(sprintf("https://docs.google.com/uc?id=%s&export=download", id),
sep=sep,dec=dec,integer64 = "character"))
}
datos<-Leer_Drive("https://drive.google.com/file/d/18RuUXzfchJiObtph-orGYMaGsA9hZ9Og/view?usp=sharing",sep=";")
id <- "18RuUXzfchJiObtph-orGYMaGsA9hZ9Og" # google file ID
read.csv(sprintf("https://docs.google.com/uc?id=%s&export=download", id))
library(tidyverse)
id <- "18RuUXzfchJiObtph-orGYMaGsA9hZ9Og" # google file ID
read_delim(sprintf("https://docs.google.com/uc?id=%s&export=download", id), delim = |)
read_delim(sprintf("https://docs.google.com/uc?id=%s&export=download", id))
data = read_delim(sprintf("https://docs.google.com/uc?id=%s&export=download", id))
data = read_delim(sprintf("https://docs.google.com/uc?id=%s&export=download", id),
delim = "|")
data = read_delim(sprintf("https://docs.google.com/uc?id=%s&export=download",
"18RuUXzfchJiObtph-orGYMaGsA9hZ9Og"), delim = "|")
install.packages(c("cli", "conquer", "gert", "glue", "igraph", "lmtest", "nloptr", "RcppArmadillo", "readr", "sessioninfo", "tibble", "uuid", "vroom", "xfun"))
install.packages("readr")
install.packages(c("conquer", "fdrtool", "gert", "glue", "igraph", "lmtest", "nloptr", "RcppArmadillo", "readr", "tibble", "uuid", "vroom", "xfun"))
install.packages("readr")
install.packages("Rtools")
Sys.which("make")
install.packages(c("conquer", "fdrtool", "gert", "glue", "igraph", "lmtest", "nloptr", "RcppArmadillo", "readr", "tibble", "uuid", "vroom", "xfun"))
install.packages("igraph")
install.packages("nloptr")
update.packages(ask = FALSE, checkBuilt = TRUE)
tinytex::tlmgr_update()
tinytex::reinstall_tinytex()
install.packages("pdfLatex")
install.packages("pdflatex")
options(tinytex.verbose = TRUE)
install.packages("tinytex")
install.packages("tinytex")
tinytex::reinstall_tinytex()
install.packages(tlmgr)
install.packages("tlmgr")
tinytex::reinstall_tinytex()
tinytex::parse_packages()
remotes::install_github('yihui/tinytex')
remotes::install_github('yihui/tinytex')
tinytex::tlmgr_update()
library(tinytex)
tinytex::tlmgr("--version")
install.packages("TinyTex")
tinytex::tinytex_root()
tinytex::install_tinytex()
data("countries")
pacman::p_load(tidyverse,
zoo,
beepr,
openxlsx,
viridis,
hrbrthemes,
bibliometrix
)
data("countries")
asia = filter(countries, CONTINENT == "ASIA")
View(countries)
asia = filter(countries, continent == "ASIA")
View(asia)
asia$countries
asia = asia$countries
asia
install.packages(c("rbibutils", "RSQLite", "sessioninfo", "sjmisc", "testthat"))
### 1. Set up ----
getwd()
setwd("G:/My Drive/Teaching/Taller SNA Valentina/intro-sna-vale")
pacman::p_load(igraph, statnet, viridis)
first_matrix = matrix(
c(0,1,0,0,
0,0,0,0,
0,0,0,1,
0,1,0,0),
nrow = 4, ncol = 4, byrow = TRUE)
first_net = graph.adjacency(first_matrix)
net_undirect = graph.adjacency(first_matrix, mode = 'undirected')
plot(first_net)
plot(net_undirect)
# 2.2 Lista de enlaces
ego = c(1,3,3,2,4)
alter = c(2,4,1,3,2)
elist = data.frame(ego, alter)
elist
my_net = graph.data.frame(elist)
# Grafo no dirigido: agregar el argumento "directed"
my_net_ud = graph.data.frame(elist, directed = FALSE)
plot(my_net)
plot(my_net_ud)
# 2.3 Matriz de incidencia (redes modo 2)
e1 = c(1,1,1,0,0,0)
e2 = c(0,1,1,1,0,0)
e3 = c(0,0,1,1,1,0)
e4 = c(0,0,0,0,1,1)
protest_df = data.frame(e1,e2,e3,e4) # Eventos de protesta
row.names(protest_df) = c("Alejandro", "Matías", "Valentina", # Nombre de nodos
"Daniela", "Agnes", "Hoshi")
protest_events_net = graph.incidence(protest_df)
summary(protest_events_net)
# Graficar red modo 2
plt.x = c(rep(2,6), rep(4,4))
plt.y = c(7:2, 6:3)
lay = as.matrix(cbind(plt.x, plt.y))
shapes = c("circle", "square")
colors = c("blue", "red")
plot(protest_events_net, vertex.color = colors[V(protest_events_net)$type+1],
vertex.shape = shapes[V(protest_events_net)$type+1],
vertex.size = 10, vertex.label.degree = -pi/2,
vertex.label.dist = 1.2, vertex.label.cex = 0.9,
layout = lay)
plot(protest_events_net, vertex.color = colors[V(protest_events_net)$type+1],
vertex.shape = shapes[V(protest_events_net)$type+1],
vertex.size = 10, vertex.label.degree = -pi/2,
vertex.label.dist = 1.2, vertex.label.cex = 0.9)
plot(protest_events_net, vertex.color = colors[V(protest_events_net)$type+1],
vertex.shape = shapes[V(protest_events_net)$type+1],
vertex.size = 10, vertex.label.degree = -pi/2,
vertex.label.dist = 1.2, vertex.label.cex = 0.9,
layout = lay)
# Transformar a red modo 1 (co-partipación en evento de protesta)
projections = bipartite.projection(protest_events_net)
projections
projection.individuals = projections$proj1
protest_events_net_adj = get.adjacency(projection.individuals, sparse=FALSE, attr="weight")
protest_events_net_adj = graph.adjacency(protest_events_net_adj)
plot(protest_events_net_adj)
# 2.4 Bonus: contruir una red desde función make_graph (igraph)
make_graph(c("A","B", "X","Y", "A","X", "B","Z"), directed = FALSE)
# No dirigida
g1 = make_graph(~ A - X, X - Y:Z, B - A)
g1
# Dirigida
g2 = make_graph(~ A -+ X, B -+ Z, A +- X:Y, B -+ A, Y +- Z)
g2
plot(g1)
plot(g2)
### 3. Visualización usando datos reales ----
# 3.1. Datos reales: redes de una escuela (crédito a Prof. Lorena Ortega)
load("curso_vertices.Rda")
load("curso_enlaces.Rda")
red_curso = graph_from_data_frame(curso_enlaces, vertices = curso_vertices, directed = TRUE)
# 3.2. Seleccionar la red de juego
red_juego = delete_edges(red_curso, E(red_curso)[question != "play"])
red_juego
plot(red_juego, edge.arrow.size = 0.3)
plot(red_juego,
edge.color = "indianred4", # Color del enlace (usa hex codes o etiquetas de colores de R)
edge.arrow.size = 1, # Tamaño de la fecha
vertex.color = V(red_juego)$female + 1) # Crea una secuencia de vértices para todos los vértices del grafo
# También podemos operar sobre el objeto igraph de forma secuencial (función V() y E())
game_net = red_juego
# También podemos operar sobre el objeto igraph de forma secuencial (función V() y E())
game_net = red_juego
V(game_net)$color = ifelse(V(game_net)$female, "#FCFF8F", "#C0FF6A")
E(game_net)$color = "black"
E(game_net)$arrow.size = 0.2
plot(game_net)
# También podemos operar sobre el objeto igraph de forma secuencial (función V() y E())
game_net = red_juego
V(game_net)$color = ifelse(V(game_net)$female, "#FCFF8F", "#C0FF6A")
E(game_net)$color = "black"
E(game_net)$arrow.size = 0.2
plot(game_net)
# Color de vértices y enlaces
plot(red_juego, vertex.color = viridis(vcount(red_juego)), # para cada vértice asigna un color de la paleta viridis.
edge.color = "black", edge.arrow.size = 0.4)
plot(red_juego, edge.color = viridis(ecount(red_juego)), vertex.color = "white", edge.arrow.size = 0.5)
# Estilo y ancho de los enlaces
plot(red_juego, edge.width = 2, edge.arrow.size = 0.2, edge.curved = 0.2,
edge.color = "black", vertex.color = "red", vertex.frame.color = "white", vertex.label = NA)
# Forma y tamaño de los vértices
plot(red_juego,
vertex.shape = ifelse(V(red_juego)$female, "circle", "square"), # Distingue hombres y mujeres por forma
vertex.size = scales::rescale(degree(red_juego), c(5,15)), # Tamaño según degree (n enlaces adyacentes)
vertex.label = NA, edge.arrow.size = 0.3, edge.color = "black")
# Forma y tamaño de los vértices
plot(red_juego,
vertex.shape = ifelse(V(red_juego)$female, "circle", "square"), # Distingue hombres y mujeres por forma
vertex.size = scales::rescale(degree(red_juego), c(5,15)), # Tamaño según degree (n enlaces adyacentes)
vertex.label = NA, edge.arrow.size = 0.3, edge.color = "black")
# Forma y tamaño de los vértices
plot(red_juego,
vertex.shape = ifelse(V(red_juego)$female, "circle", "square"), # Distingue hombres y mujeres por forma
vertex.size = scales::rescale(degree(red_juego), c(5,15)), # Tamaño según degree (n enlaces adyacentes)
vertex.label = NA, edge.arrow.size = 0.3, edge.color = "black")
# Etiquetas de texto
plot(red_juego, vertex.label.cex = 0.7, vertex.label.color = "white", vertex.color = "blue",
vertex.label = seq(1, vcount(red_juego)), # Etiqueta los nodos contando desde 1. Default = etiqueta en variable "name"
vertex.size = 15,
edge.arrow.size = 0.2, edge.color = "black")
plot(red_juego, vertex.color = "blue", vertex.label = NA, vertex.size = 5, edge.arrow.size = 0.2,
edge.label = seq(1, ecount(red_juego)), edge.label.cex= 0.7, # Etiqueta los enlaces
edge.color="black")
# Marcando grupos
set.seed(270122)
plot(red_juego, mark.groups = list(
V(red_juego)[female], V(red_juego)[!female] ), # Genera una lista por género del nodo
mark.col = adjustcolor(c("red", "blue"), 0.1), mark.border = c("red", "blue"),
vertex.shape = ifelse(V(red_juego)$female, "circle", "square"), vertex.label = NA,
edge.arrow.size = 0.2, edge.color = "black")
### 4. Díadas y tríadas ----
# - Densidad
graph.density(red_juego) # d = 0.135.
# - Reciprocidad
reciprocity(red_juego) # la reciprocidad es igual a 0.5; ¿cómo interpretamos?
# La función erdos.renyi.game genera una red del mismo tamaño y densidad, pero con enlaces emitidos al azar
random_graph = erdos.renyi.game(n = vcount(red_juego), # Número de nodos
p.or.m = graph.density(red_juego), # Probabilidad de generar un enlace entre dos nodos
directed = TRUE) # La red es dirigida
# Comprobación visual de ambos grafos
plot(red_juego,
vertex.size = 10,
vertex.label = NA,
edge.curved = .1,
vertex.color = "tomato",
edge.arrow.size = .1,
edge.width = .5,
edge.color = "grey60")
plot(random_graph,
vertex.size = 10,
vertex.label = NA,
edge.curved = .1,
vertex.color = "tomato",
edge.arrow.size = .1,
edge.width = .5,
edge.color = "grey60")
# - ¿Cuál es la reciprocidad del grafo aleatorio?
reciprocity(random_graph)
# - Homofilia
assortativity_nominal(red_juego, types = as.numeric(V(red_juego)$female) + 1)
# - Tríadas: transitividad
transitivity(red_juego)
# - Tríadas: censo de tríadas
triad.census(red_juego)
# - Tríadas: censo de tríadas
triad.census(red_juego)
red_juego = as_edgelist(red_juego)
# - Tríadas: censo de tríadas
triad.census(red_juego)
# - Tríadas: transitividad
transitivity(red_juego)
